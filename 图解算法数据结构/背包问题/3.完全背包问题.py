"""
完全背包模板：
完全背包指的是所有物品选择没有数量限制。

f[i][j] 表示只看前i个物品，总体积是j的情况下，总价值最大是多少。

result = max(f[n][0~V]) f[i][j]:
不选第i个物品：f[i][j] = f[i-1][j];
选第i个物品：f[i][j] = f[i-1][j-k * v[i]] + w[i]（v[i]是第i个物品的体积） 两者之间取最大。
"""


def compKnap(num, capacity, weightList, valueList):
    valueExcel = [[0 for j in range(capacity + 1)] for i in range(num + 1)]
    for i in range(1, num + 1):
        for j in range(1, capacity + 1):
            """
            完全背包问题跟01背包问题最大的区别就是每一个物品可以选无数次，因此当我们考虑到第i个物品时，
            我们应该考虑的情况是：不选这个物品、选一次这个物品、选两次这个物品......，直到不能再选
            （选的次数k，k*v[i] > j，j为当前背包容量），然后再从这些情况中选最大的。
            """
            for k in range((j // weightList[i - 1]) + 1):
                valueExcel[i][j] = max(valueExcel[i - 1][j - k * weightList[i - 1]] + k * valueList[i - 1], valueExcel[i][j])
    return valueExcel


print(compKnap(5, 16, [5, 4, 7, 2, 6], [12, 3, 10, 3, 6]))
"""
输出结果为：
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 12, 12, 12, 12, 12, 24, 24, 24, 24, 24, 36, 36],
 [0, 0, 0, 0, 3, 12, 12, 12, 12, 15, 24, 24, 24, 24, 27, 36, 36],
 [0, 0, 0, 0, 3, 12, 12, 12, 12, 15, 24, 24, 24, 24, 27, 36, 36],
 [0, 0, 3, 3, 6, 12, 12, 15, 15, 18, 24, 24, 27, 27, 30, 36, 36],
 [0, 0, 3, 3, 6, 12, 12, 15, 15, 18, 24, 24, 27, 27, 30, 36, 36]]
"""
